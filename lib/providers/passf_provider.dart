import 'dart:io';
import 'dart:typed_data';
import 'dart:convert' show utf8;
import 'package:path_provider/path_provider.dart';
import 'dart:collection';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:git_bindings/git_bindings.dart';
import 'package:openpgp/openpgp.dart';
import 'package:archive/archive_io.dart';
import 'package:share_plus/share_plus.dart';
import 'package:intl/intl.dart';
import '../constants.dart';
import '../models/passf_model.dart';

class Passwords with ChangeNotifier {
  List<PasswordEntry> _items = [];
  List<PasswordEntry> _savedItems = [];
  SnapshotEntry _snapshot;
  GitRepo _gitRepo;
  String _gitPath;
  SharedPreferences prefs;
  String gitUrl, _gitPrivateKey, _gitPublicKey, _gitCommitName, _gitCommitEmail;
  String gpgPassphrase, _gpgPrivateKey, _gpgPublicKey;
  bool showFolders;
  bool gpgSavePassphrase;
  bool securityBiometric;
  bool reloading = false;
  DateTime pausedDate = DateTime.now();
  bool gitInitialized = false;
  String path;
  bool recursive = false;
  String searchFilter = "";
  int clipboardTimeout;
  bool debugMode = (testGitUrl!='');

  Passwords({
    path,
    recursive,
    searchFilter,
  }) {
    loadPasswords();
  }

  Future<void> setTestSettings() async {
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final secureStorage = new FlutterSecureStorage();
    await prefs.setString('git_url', testGitUrl);
    await prefs.setString('git_commitname', appName);
    await prefs.setString('git_commitemail', authorEMail);
    await secureStorage.write(key: 'git_privatekey', value: testGitPrivateKey);
    await secureStorage.write(key: 'git_publickey', value: testGitPublicKey);
    await secureStorage.write(key: 'gpg_passphrase', value: testGPGPassphrase);
    await secureStorage.write(key: 'gpg_privatekey', value: testGPGPrivateKey);
    await secureStorage.write(key: 'gpg_publickey', value: testGPGPublicKey);
    await prefs.setBool('gpg_savepassphrase', true);
    await prefs.setBool('advanced_showfolders', true);
    await prefs.setBool('advanced_askdialogs', false);
    await prefs.setBool('security_biometric', false);
    await saveGitKeys(testGitPrivateKey, testGitPublicKey);
  }

  Future<void> initSettings() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    if (!prefs.containsKey('git_commitname'))
      await prefs.setString('git_commitname', appName);
    if (!prefs.containsKey('git_commitemail'))
      await prefs.setString('git_commitemail', authorEMail);
    if (!prefs.containsKey('gpg_savepassphrase'))
      await prefs.setBool('gpg_savepassphrase', false);
    if (!prefs.containsKey('advanced_showfolders'))
      await prefs.setBool('advanced_showfolders', true);
    if (!prefs.containsKey('advanced_askdialogs'))
      await prefs.setBool('advanced_askdialogs', true);
    if (!prefs.containsKey('security_biometric'))
      await prefs.setBool('security_biometric', false);
    if (!prefs.containsKey('advanced_clipboardtimeout'))
      await prefs.setString('advanced_clipboardtimeout', '60s');
  }

  Future<void> loadSettings() async {
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final secureStorage = new FlutterSecureStorage();

    //Testing values
    //await setTestSettings();

    gitUrl = prefs.getString('git_url') ?? '';
    _gitCommitName = prefs.getString('git_commitname');
    _gitCommitEmail = prefs.getString('git_commitemail');
    _gitPrivateKey = await secureStorage.read(key: 'git_privatekey');
    _gitPublicKey = await secureStorage.read(key: 'git_publickey');
    gpgPassphrase = await secureStorage.read(key: 'gpg_passphrase') ?? '';
    _gpgPrivateKey = await secureStorage.read(key: 'gpg_privatekey');
    _gpgPublicKey = await secureStorage.read(key: 'gpg_publickey');
    gpgSavePassphrase = prefs.getBool('gpg_savepassphrase');
    showFolders = prefs.getBool('advanced_showfolders') ?? true;
    recursive = !showFolders;
    securityBiometric = prefs.getBool('security_biometric');
    gitInitialized = (await Directory(_gitPath).exists()) ? true : false;
    clipboardTimeout = int.parse(
            prefs.getString('advanced_clipboardtimeout').replaceAll('s', '')) ??
        60;
  }

  Future<String> generateGitKeys() async {
    try {
      return await generateSSHKeys(comment: 'generated by $appName');
    } catch (e) {
      // If encountering an error, return null
      _sendError(e.toString());
      return null;
    }
  }

  Future<void> saveGitKeys(String privateKey, String publicKey) async {
    try {
      setSshKeys(publicKey: publicKey, privateKey: privateKey);
    } on GitException catch (ex) {
      print('ERROR: $ex');
    }
  }

  Future<String> getGitPrivateKey() async {
    try {
      final appPath = await _localAppPath;
      final key = File(appPath + '/ssh/id_rsa').readAsStringSync();
      return key;
    } catch (e) {
      // If encountering an error, return null
      _sendError(e.toString());
      return null;
    }
  }

  Future<String> getGitPublicKey() async {
    try {
      final appPath = await _localAppPath;
      final key = File(appPath + '/ssh/id_rsa.pub').readAsStringSync();
      return key;
    } catch (e) {
      // If encountering an error, return null
      _sendError(e.toString());
      return null;
    }
  }

  Future<void> cloneGit() async {
    if (!await Directory(_gitPath).exists() && gitUrl.isNotEmpty) {
      try {
        reloading = true;
        notifyListeners();
        await GitRepo.clone(_gitPath, gitUrl);
        _sendSuccess("Git clone succeed");
        gitInitialized = true;
      } on GitException catch (ex) {
        _sendError(ex.toString());
      }
      reloading = false;
      notifyListeners();
    }
  }

  Future<KeyPair> generateGpgKeys(String passphrase) async {
    var keyOptions = KeyOptions()..rsaBits = 4096;
    return await OpenPGP.generate(
        options: Options()
          ..name = appName
          ..email = authorEMail
          ..passphrase = passphrase
          ..keyOptions = keyOptions);
  }

  Future<void> loadPasswords() async {
    _gitPath = await _localGitPath;
    path ??= _gitPath;
    _gitRepo = GitRepo(folderPath: _gitPath);
    await initSettings();
    await loadSettings();
    await cloneGit();
    if (await Directory(path).exists()) {
      _items = await _filesLoad(recursive);
      _savedItems = _items;
      notifyListeners();
    }
  }

  Future<void> reloadPasswords() async {
    print("reloadPasswords");
    if (await Directory(path).exists()) {
      _savedItems = await _filesLoad(recursive);
      _items = searchFilter.isEmpty
          ? _savedItems
          : _savedItems
              .where((item) => item.name.toLowerCase().contains(searchFilter.toLowerCase()))
              .toList();
    } else {
      _items.clear();
      _savedItems.clear();
    }
    notifyListeners();
  }

  Future<bool> syncPasswords() async {
    try {
      await cloneGit();
      await _gitRepo.pull(
          authorEmail: _gitCommitEmail, authorName: _gitCommitName);
      reloadPasswords();
      _gitRepo.push();
      return true;
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }

  List<PasswordEntry> get items {
    return UnmodifiableListView<PasswordEntry>(_items);
  }

  String get gitPath {
    return _gitPath;
  }

  Future<void> savePassword(
      int index, PasswordEntry password, String content, String op) async {
    String _action;

    password.path ??= p.join(_gitPath, password.name + '.' + passwordFilesExtension);

    if (op == 'add') {
      _action = "added";
      //password.path = p.join(Directory(path).path, password.name + '.gpg');
    } else if (op == 'edit') {
      _action = "modified";
      //_parentDir = File(_items[index].path).parent.path;
      //password.path = p.join(_gitPath, password.name + '.gpg');
    } else {
      _action = "restored";
    }

    await _writePasswordFile(password, content);

    //Remove old entry when entry has been renamed
    if ((op == 'edit') && (password.path != _items[index].path))
      await removePassword(index);
    await _gitRepo.add(password.path.substring(_gitPath.length + 1));
    await _gitRepo.commit(
        authorEmail: _gitCommitEmail,
        authorName: _gitCommitName,
        message: password.name + " " + _action);

    reloadPasswords();
  }

  Future<String> readPassword(int index) async {
    //final result =  await _readPasswordFile(_items[index]);
    //return (result != null) ? result : "Error decrypting";
    return await _readPasswordFile(_items[index]);
      }

  Future<bool> removePassword(int index) async {
    final name = _items[index].path.substring(_gitPath.length + 1,
        _items[index].path.length - passwordFilesExtension.length - 1);
    final String msg = name + " deleted";

    try {
      await _gitRepo.rm(_items[index].path.substring(_gitPath.length + 1));
      await _gitRepo.commit(
          authorEmail: _gitCommitEmail,
          authorName: _gitCommitName,
          message: msg);
      // Remove in case it was not in repo.
      await _rmPasswordFile(_items[index]);
      reloadPasswords();
      return true;
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }

  Future<bool> removeDirectory(int index) async {
    final String msg = items[index].name + " deleted";
    try {
      final result = await _rmPasswordDirectory(_items[index]);
      /*await _gitRepo.add('.');
      await _gitRepo.commit(
          authorEmail: _gitCommitEmail,
          authorName: _gita&CommitName,
          message: msg);*/
      reloadPasswords();
      return result;
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }

  Future<void> createSnapshot(int index) async {
    final _content = await readPassword(index);

    _snapshot = SnapshotEntry(
      path: _items[index].path,
      name: _items[index].path.substring(_gitPath.length + 1,
          _items[index].path.length - passwordFilesExtension.length - 1),
      content: _content,
    );
  }

  Future<void> restoreSnapshot() async {
    final _password = PasswordEntry(
      id: null,
      name: _snapshot.name,
      path: _snapshot.path,
      type: 'File',
    );
    await savePassword(null, _password, _snapshot.content, 'restore');
  }

  Future<void> undoLast() async {
    await _gitRepo.resetLast();
    reloadPasswords();
  }

  Future<void> discardLocal() async {
    if (await Directory(_gitPath).exists()) {
      try {
        await _rmDir(_gitPath);
        _items.clear();
        _savedItems.clear();
        path = _gitPath;
        gitInitialized=false;
        notifyListeners();
        _sendSuccess("Local data discarded");
      } on GitException catch (ex) {
        _sendError(ex.toString());
      }
    }
  }

  String generatePassword(bool _isWithLetters, bool _isWithUppercase,
      bool _isWithNumbers, bool _isWithSpecial, double _numberCharPassword) {
    //Define the allowed chars to use in the password
    String _lowerCaseLetters = "abcdefghijklmnopqrstuvwxyz";
    String _upperCaseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    String _numbers = "0123456789";
    String _special = "!\$%@#";

    //Create the empty string that will contain the allowed chars
    String _allowedChars = "";

    //Put chars on the allowed ones based on the input values
    _allowedChars += (_isWithLetters ? _lowerCaseLetters : '');
    _allowedChars += (_isWithUppercase ? _upperCaseLetters : '');
    _allowedChars += (_isWithNumbers ? _numbers : '');
    _allowedChars += (_isWithSpecial ? _special : '');

    int i = 0;
    String _result = "";

    //Create password
    while (i < _numberCharPassword.round()) {
      //Get random int
      int randomInt = Random.secure().nextInt(_allowedChars.length);
      //Get random char and append it to the password
      _result += _allowedChars[randomInt];
      i++;
    }

    return _result;
  }

  Future<String> decryptSymmetricFile(File file, String passphrase) async {
    try {
      var contents =
          await OpenPGP.decryptSymmetric(file.readAsStringSync(), passphrase);
      return contents;
    } catch (e) {
      _sendError(e.toString());
      return null;
    }
  }

  Future<bool> archivePasswords() async {
    var encoder = ZipFileEncoder();
    final _path = await _localAppPath;
    DateTime date = DateTime.now();

    final archiveFilename = p.join(Directory(_path).path,
        "passF_" + DateFormat('ddMMyy').format(date) + ".zip");
    print("archiveFilename: " + archiveFilename);

    try {
      _rmfFile(archiveFilename);
      encoder.zipDirectory(Directory(_gitPath), filename: archiveFilename);
      await Share.shareFiles([archiveFilename]);
      _rmfFile(archiveFilename);
      return true;
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }



  Future<bool> exportKeyToFile(bool encrypted,String passphrase, String filePrefix, String key) async {
    var encoder = ZipFileEncoder();
    final _path = await _localAppPath;
    DateTime date = DateTime.now();
    String fileText;

    // Easy password in Debug mode
    //passphrase = kReleaseMode ? passphrase : DateFormat('ddMMyy').format(date);

    var archiveFilename = p.join(Directory(_path).path,
        filePrefix + "_" + DateFormat('ddMMyy').format(date)+ ".asc");

    try {

      if (encrypted) {
        archiveFilename = archiveFilename + ".sec";
        fileText = await OpenPGP.encryptSymmetric(key, passphrase);
      } else {
        fileText = key;
      }

        print("archiveFilename: " + archiveFilename);
        _rmfFile(archiveFilename);

        final file = File(archiveFilename);
        await file.writeAsString(fileText);
        await Share.shareFiles([archiveFilename]);
        _rmfFile(archiveFilename);

        return true;
      } catch (e) {
        _sendError(e.toString());
        return false;
      }
    }

  Future<void> backToRoot() async {
    path = await _localGitPath;
  }

  Future<DateTime> getLastModified(int index) async {
    final file = await _localFile(_items[index]);
    return file.lastModifiedSync();
  }

  Future<String> getFilePath(int index) async {
    final file = await _localFile(_items[index]);
    return file.path;
  }


  Future<List<String>> getDirectoriesList() async {
    final _path = await _localGitPath;;
    final directory = new Directory(_path);
    List<FileSystemEntity> _files;
    List<String> _filteredFiles = [];

    _files = directory.listSync(recursive: true, followLinks: false);
    _files.sort((a, b) => a.path.compareTo(b.path));

    String _name;

    //Just keep files with right extension and dirs
    for (var file in _files) {
      if ((file is Directory) &&
          (!file.path.startsWith(p.join(_gitPath, '.git')))) {
        _name = file.path.substring(_path.length + 1);
        _filteredFiles.add(_name+"/");
        //print('name: $_name');
      }
    }
    return _filteredFiles;
  }
// --------------------------
// Internal Repo Routines
// --------------------------

  void _sendSuccess([String text]) {
    text ??= "Success";
    print('SUCCESS: $text');
/*    ScaffoldMessenger.of(context)
      ..removeCurrentSnackBar()
      ..showSnackBar(SnackBar(content: Text(text)));*/
  }

  void _sendError([String text]) {
    text ??= "Error";
    print('ERROR: $text');
/*    ScaffoldMessenger.of(context)
      ..removeCurrentSnackBar()
      ..showSnackBar(SnackBar(content: Text("ERROR: " + text)));*/
  }

  Future<String> get _localAppPath async {
    final directory = await getApplicationSupportDirectory();
    return directory.path;
  }

  Future<String> get _localGitPath async {
    final _path = await _localAppPath;
    return p.join(Directory(_path).path, gitFolderName);
  }

  Future<File> _localFile(PasswordEntry password) async {
    return File(password.path);
  }

  Future<Directory> _localDirectory(PasswordEntry password) async {
    return Directory(password.path);
  }

  Future<List<PasswordEntry>> _filesLoad(bool recursive) async {
    //final _gitPath = await _localGitPath;
    //final _path = this.path ?? _gitPath;
    final _path = path;
    final directory = new Directory(_path);
    List<FileSystemEntity> _files;
    List<FileSystemEntity> _filteredFiles = [];

    _files = directory.listSync(recursive: recursive, followLinks: false);
    _files.sort((a, b) => a.path.compareTo(b.path));

    String _name;
    String _meta;

    if (!path.endsWith(gitFolderName) && !recursive)
      _filteredFiles.add(Directory(path).parent);
    //Just keep files with right extension and dirs
    for (var file in _files) {
      if ((file is File) && ( file.path.toString().endsWith('.gpg') ||
          file.path.toString().endsWith('.pgp'))) {
        _filteredFiles.add(file);
      } //folders
      if ((file is Directory) &&
          (!recursive) &&
          (!file.path.startsWith(p.join(_gitPath, '.git')))) {
        _filteredFiles.add(file);
      }
    }

    return List.generate(_filteredFiles.length, (i) {
      //print (_filteredFiles[i]);
      if (_filteredFiles[i] is File) {
        _name = _filteredFiles[i].path.split('/').last;
        _name = _name.substring(
            0, _name.length - passwordFilesExtension.length - 1);
        _meta = File(_filteredFiles[i].path).lastModifiedSync().toString();
      } else {
        //_name = (_filteredFiles[i].path.endsWith(gitFoderName)) ? _filteredFiles[i].path.substring(_path.length + 1) : '..' ;
        _name = (i == 0 && !path.endsWith(gitFolderName))
            ? '..'
            : _filteredFiles[i].path.substring(_path.length + 1);
        _meta = Directory(_filteredFiles[i].path)
            .listSync(recursive: true, followLinks: false)
            .where(
                (item) => item.path.toString().endsWith(passwordFilesExtension))
            .toList()
            .length
            .toString();
      }
      return PasswordEntry(
        id: UniqueKey().toString(),
        name: _name,
        path: _filteredFiles[i].path,
        type: _filteredFiles[i] is File ? 'File' : 'Directory',
        meta: _meta,
      );
    });
  }

  Future<String> _readPasswordFile(PasswordEntry password) async {
    try {
      final file = await _localFile(password);

      var contents = await OpenPGP.decryptBytes(
        file.readAsBytesSync(),
        _gpgPrivateKey,
        gpgPassphrase,
      );
      //return  String.fromCharCodes(contents);
      return utf8.decode(contents);
    } catch (e) {
      _sendError(e.cause.toString());
      //When key is wrong return password to "###WK###"
      if (e.cause.toString().contains('private key checksum failure')) {
        return "###WK###";
      }
      return null;
    }
  }

  Future<bool> _writePasswordFile(PasswordEntry password, String text) async {
    final file = await _localFile(password);

    try {
      if (!await file.parent.exists()) {
        // create folder if it doesn't exist
        await file.parent.create(recursive: true);
      }

      var contents = await OpenPGP.encryptBytes(
        Uint8List.fromList(utf8.encode(text)),
        _gpgPublicKey,
      );
      file.writeAsBytesSync(contents);
      return true;
    } catch (e) {
      // If encountering an error, return null
      _sendError(e.cause.toString());
      return false;
    }
  }

  Future<bool> _rmPasswordFile(PasswordEntry password) async {
    final file = await _localFile(password);
    try {
      file.deleteSync();
      return true;
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }

  Future<bool> _rmPasswordDirectory(PasswordEntry password) async {
    final directory = await _localDirectory(password);
    try {
      directory.deleteSync(recursive: true);
      return true;
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }

  Future<void> _rmDir(String folderPath) async {
    try {
      await Directory(folderPath).exists().then((exist) {
        if (exist) Directory(folderPath).deleteSync(recursive: true);
      });
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }

  Future<void> _rmfFile(String filePath) async {
    try {
      await File(filePath).exists().then((exist) {
        if (exist) File(filePath).deleteSync();
      });
    } catch (e) {
      _sendError(e.toString());
      return false;
    }
  }
}
